package tracking;

import ij.ImagePlus;
import ij.process.ByteProcessor;
import ij.process.ImageProcessor;

import java.util.ArrayList;
import java.util.Arrays;

import cloud.Cloud;
import cloud.CloudPair;
import cloud.Vec2;

public class Tracking {

	
	public static ArrayList<Cloud> Tracking (ArrayList<CloudPair> ref, ImageProcessor binary, int numOfIteration){
		System.out.println("Tracking" + numOfIteration);
		
		ArrayList<Cloud> currentCorrespondence = new ArrayList<Cloud>();
		
		int white = 255;
		int [] pixels = (int[]) binary.getPixels();
		int length = pixels.length;
		int binWidth  = binary.getWidth();
		//int binHeight = binary.getHeight();  //unnötig
		
		
		for(int i = 0; i < ref.size(); i++)
		{
			
			CloudPair previousPair = ref.get(i);
			Cloud correspondence = previousPair.getCorrespondence();
			int corrHeight = correspondence.getHeight();
			int corrWidth = correspondence.getWidth();
			int corrCenterX = correspondence.getX();
			int corrCenterY = correspondence.getY();
			Vec2 motion = previousPair.getMotionVec();
			int dirX = motion.getX();
			int dirY = motion.getY();
			//String direction = previousPair.getVecDirection(); //unnötig
			
			int estimatedCenterX;
			int estimatedCenterY;
			int heightTop = 0;
			int heightBottom = 0;
			int widthLeft = 0;
			int widthRight = 0;
			
			// Pruefe, ob das geschätzte neue Zentrum der Wolke innerhalb des Bildes liegt
			if(corrCenterX + dirX + corrCenterY + dirY * binWidth >= 0 && corrCenterX + dirX + corrCenterY + dirY * binWidth < length){
				
				estimatedCenterX = corrCenterX + dirX;
				estimatedCenterY = corrCenterY + dirY;
				
				//Pruefe ob das Pixle im Binärbild weiß ist, also ob es ein Wolkenpixel ist
				if(pixels[estimatedCenterX + binWidth * estimatedCenterY] == white){
					
					
					//Dann laufe der Höhe und Breite entsprechend vom Zentrum ausgehend durch das "pixels"-Array und bestimme die neue Höhe und Breite
					
					//oben
					
					for(int j = 0; j < corrHeight / 2; j++){
						
					//Abfrage, ob Arraygrenzen nicht überschritten werden
						if(estimatedCenterX + binWidth * (estimatedCenterY - j) >= 0 && estimatedCenterX + binWidth * (estimatedCenterY - j) < length){
							if(pixels[estimatedCenterX + binWidth * (estimatedCenterY - j)] != white)
								heightTop = j;
							else 
								heightTop++;
						}
						else
							break;
					}	
					
					//unten
					
					for(int g = 0; g < corrHeight / 2; g++){
						
					
					//Abfrage, ob Arraygrenzen nicht überschritten werden
						if(estimatedCenterX + binWidth * (estimatedCenterY + g) >= 0 && estimatedCenterX + binWidth * (estimatedCenterY + g) < length){
						
							if(pixels[estimatedCenterX + binWidth * (estimatedCenterY + g)] != white)
								heightBottom = g;
							else
								heightBottom++;
						}
						else
							break;
					}
					
					//links
					
					for(int h = 0; h < corrWidth / 2; h++){
						
					//Abfrage, ob Arraygrenzen nicht überschritten werden
						if(estimatedCenterX - h + binWidth * estimatedCenterY >= 0 && estimatedCenterX - h + binWidth * estimatedCenterY < length){	
						
							if(pixels[estimatedCenterX - h + binWidth * estimatedCenterY] != white)
								widthLeft = h;
							else 
								widthLeft++;
						}
						else
							break;
					}
					
					//rechts
					 
					for(int k = 0; k < corrWidth / 2; k++){
						
					//Abfrage, ob Arraygrenzen nicht überschritten werden
						if(estimatedCenterX + k + binWidth * estimatedCenterY >= 0 && estimatedCenterX + k + binWidth * estimatedCenterY < length){		
						
							if(pixels[estimatedCenterX + k + binWidth * estimatedCenterY] != white)
								widthRight = k;
							else 
								widthRight++;
						}
						else
							break;
					}
					
					
					int tmpWidth = Math.abs(widthLeft) + Math.abs(widthRight);
					int tmpHeight = Math.abs(heightTop) + Math.abs(heightBottom);
					
					Cloud toAdd = new Cloud(estimatedCenterX, estimatedCenterY, tmpWidth, tmpHeight,numOfIteration);
					currentCorrespondence.add(toAdd);
				}
				
			}
			
			
			//Andernfalls liegt das Zentrum nicht mehr im Bild
			else
				continue;
			
		}
		
		
		return currentCorrespondence;
	}
	
//	---------------------------------------------------------------------------------------------------------------

	public static ArrayList<Cloud> startTracking(ImageProcessor binary, int numOfIteration){
		System.out.println("startTracking" + numOfIteration);
		
		ArrayList<Cloud> cloudList = new ArrayList<Cloud>();
//		int [] pixelsB = ArrayConv.getPix(binary);
			
	//zu kleine wolken
		int minW=10;
		int minH=10;
		int minA=150;
		
		int white = -1;
		int widthP = binary.getWidth();
		int heightP = binary.getHeight();
		//counter für grauwert der einzelnen wolken
		byte hueC=10;
		//counter für nummerierung der wolken
		byte nC=0;
		
		//binärbild anzeigen
//		ImagePlus ipb=new ImagePlus("binary",binary);
//		ipb.show();
	
	

		//bilder werden leer
		byte[] pixelB= (byte[])binary.getPixels();
		int[][] pixels2 = binary.getIntArray();

		byte[]pixels=ArrayConv.two2oneB(pixels2);
		
		ImageProcessor ip= new ByteProcessor(widthP,heightP, pixelB);
		ImagePlus imp =new ImagePlus("binary",ip);
		imp.show();
		
		pixels=pixelB;
		
		
//		Arrays.sort(pixels);			// muss ausgeschaltet sein
//		System.out.println("min." + pixels[0]);
//		System.out.println("max:" + pixels[pixels.length-1]);
		
		
		int length = pixels.length;
		
		//merkerbild
		boolean [] marker = new boolean[pixels.length];
		byte [] markerB =new byte[length]; 
		//kontrollbild zur anzeige
		byte [] show = new byte[length];
		
		
		ArrayList <int[]> fifo = new ArrayList<int[]>();
		
		
		for(int y = 0; y < heightP; y++ ){
			for(int x = 0; x < widthP; x++){
				
				//startpunkt gefunden
				if(pixels[y*widthP + x] == white && !marker[y*widthP + x]){
				System.out.println("Wolke gefunden" +  " X: " + x + " Y: " + y);	
					
					hueC+=10;
					nC+=1;
					
					int[] xy={x,y};
					
					int centerX = 0, centerY = 0, cloudWidth = 0, cloudHeight = 0;
					int minX = x, minY = y, maxX = x, maxY = y;
					
					fifo.add(xy);
					
					marker[y * widthP + x] = true;
					show[y * widthP + x] = hueC;
					
					while(!fifo.isEmpty()){
						
																	
						int [] coordXY = fifo.remove(fifo.size()-1);
						
										//oben
						if((coordXY[1] - 1) * widthP + coordXY[0] > 0 && coordXY[1] != 0){
						
							if(pixels[(coordXY[1]-1) * widthP + coordXY[0]] == white && !marker[(coordXY[1]-1) * widthP + coordXY[0]]){
							
								int[] xyO={coordXY[0],coordXY[1]-1};
								fifo.add(xyO);
								if(xyO[1] * widthP < minY)
									minY=xyO[1];
									
							
								marker[(coordXY[1]-1) * widthP + coordXY[0]] = true;
								markerB[(coordXY[1]-1) * widthP + coordXY[0]] = -1;
								show[(coordXY[1]-1) * widthP + coordXY[0]] = hueC;
								}
						}
							
						
						//rechts
						if(coordXY[1] * widthP + coordXY[0] + 1 < length && coordXY[0] % widthP != (widthP-1)){
						
							if(pixels[coordXY[1] * widthP + coordXY[0] + 1]== white && !marker[coordXY[1] * widthP + coordXY[0] + 1]){
							
								int[] xyR={coordXY[0] + 1, coordXY[1]};
								fifo.add(xyR);
								if(xyR[0]>maxX)
									maxX=xyR[0];
									
										
								
								marker[coordXY[1] * widthP + coordXY[0] + 1] = true;
								markerB[coordXY[1] * widthP + coordXY[0] + 1] = -1;
								show[coordXY[1] * widthP + coordXY[0]+1] = hueC;
								}
						}
						
						
				
						
						
						
				
							
						
								//unten 
						if((coordXY[1] + 1) * widthP + coordXY[0] < length && coordXY[1] != (heightP-1)){
							
							if(pixels[(coordXY[1]+1) * widthP + coordXY[0]] == white && !marker[(coordXY[1]+1) * widthP + coordXY[0]]){
								
								int[] xyU={coordXY[0],coordXY[1]+1};
								fifo.add(xyU);
								if(xyU[1]* widthP > maxY)
									maxY=xyU[1];
									
								
								marker[coordXY[1]+1 * widthP + coordXY[0]] = true;
								markerB[coordXY[1]+1 * widthP + coordXY[0]] = -1;
								show[coordXY[1]+1 * widthP + coordXY[0]] = hueC;
								}
						}
							
						
				
						
				
	
						
						
						
				
							
				//links		
						if(coordXY[1] * widthP + coordXY[0] - 1 > 0 && coordXY[0] % widthP != 0){
						
							if(pixels[coordXY[1] * widthP + coordXY[0] - 1] == white && !marker[coordXY[1] * widthP + coordXY[0] - 1]){
							
								int[] xyL={coordXY[0] - 1,coordXY[1]};
								fifo.add(xyL);
								if(xyL[0]<minX)
									minX=xyL[0];
									
								//koordinaten zum markieren geändert
								marker[coordXY[1] * widthP + coordXY[0] - 1] = true;
								markerB[coordXY[1] * widthP + coordXY[0] - 1] = -1;
								show[coordXY[1] * widthP + coordXY[0]-1] = hueC;
								}										 
						}	
									
						
				
					
					
				
					
					//	hueC+=10; //wann stoppen?
					//	nC+=1;
					}//end while
					
												
					
					//
					centerX=minX + (maxX-minX)/2;
					centerY= minY + (maxY-minY)/2;
					cloudWidth=maxX-minX;
					cloudHeight=maxY-minY;
					
					
					//wolken mit randkontakt ausschließen
					if(minX!=0 && minY!=0 && maxX!=widthP && maxY!=heightP){
						
					Cloud tmp = new Cloud(centerX,centerY,cloudWidth,cloudHeight, numOfIteration);
					
					//falls wolke ihren schwerpunkt in einer schon bestehenden wolke hat, füge sie nicht hinzu
//					for(int i = 0; i < cloudList.size(); i++){
//						Cloud cl=cloudList.get(i);
//					if(cl.pointTest(centerX,centerY))
//						tmp=new Cloud (0,0,0,0,numOfIteration);
//						System.out.println("wolke in wolke");
//					}
					
					//geändert: wenn wolken zu klein sind, werden sie nicht hinzugefügt
					if((tmp.getHeight() > minH || tmp.getWidth() > minW) && (tmp.getHeight()*tmp.getWidth()) > minA){
						cloudList.add(tmp);
						System.out.println("wolke hinzugefügt");
						tmp.printCloud();
					}
						
					}//wolken mit randkontakt ausschließen ende
					
//					schwarze löcher füllen/ bounding box zeichnen
						for(int i=minY;i<=maxY;i++){
						for(int j=minX; j<=maxX; j++){
							marker[i*widthP+j]=true;
							markerB[i*widthP+j]=-1;
						}
					}
					
					
				}//end for
			}//end for
			
			
		}//end find borders
		
			
//		ImageProcessor ip= new ByteProcessor(widthP,heightP, show);
//		ImagePlus imp =new ImagePlus("show",ip);
//		imp.show();
		ImageProcessor ipmb= new ByteProcessor(widthP,heightP, markerB);
		ImagePlus impmb =new ImagePlus("markerB",ipmb);
		impmb.show();
		
		return cloudList;
	}
	
	//------------------------------------------------------------------------
	
//	public static ArrayList<Cloud> Tracking2 (ArrayList<CloudPair> ref, ImageProcessor binary, int numOfIteration){
//		System.out.println("Tracking" + numOfIteration);
//		
//		ArrayList<Cloud> currentCorrespondence = new ArrayList<Cloud>();
//		
//		int white = 255;
//		int [] pixels = (int[]) binary.getPixels();
//		int length = pixels.length;
//		int binWidth  = binary.getWidth();
//		//int binHeight = binary.getHeight();  //unnötig
//		
//		
//		for(int i = 0; i < ref.size(); i++)
//		{
//			
//			CloudPair previousPair = ref.get(i);
//			Cloud correspondence = previousPair.getCorrespondence();
//			int corrHeight = correspondence.getHeight();
//			int corrWidth = correspondence.getWidth();
//			int corrCenterX = correspondence.getX();
//			int corrCenterY = correspondence.getY();
//			Vec2 motion = previousPair.getMotionVec();
//			int dirX = motion.getX();
//			int dirY = motion.getY();
//			//String direction = previousPair.getVecDirection(); //unnötig
//			
//			int estimatedCenterX;
//			int estimatedCenterY;
//			int heightTop = 0;
//			int heightBottom = 0;
//			int widthLeft = 0;
//			int widthRight = 0;
//			
//			// Pruefe, ob das geschätzte neue Zentrum der Wolke innerhalb des Bildes liegt
//			if(corrCenterX + dirX + corrCenterY + dirY * binWidth >= 0 && corrCenterX + dirX + corrCenterY + dirY * binWidth < length){
//				
//				estimatedCenterX = corrCenterX + dirX;
//				estimatedCenterY = corrCenterY + dirY;
//				
//				//Pruefe ob das Pixle im Binärbild weiß ist, also ob es ein Wolkenpixel ist
//				if(pixels[estimatedCenterX + binWidth * estimatedCenterY] == white){
//					
//					
//					//Dann laufe der Höhe und Breite entsprechend vom Zentrum ausgehend durch das "pixels"-Array und bestimme die neue Höhe und Breite
//					
//					//oben
//					
//					for(int j = 0; j < corrHeight / 2; j++){
//						
//					//Abfrage, ob Arraygrenzen nicht überschritten werden
//						if(estimatedCenterX + binWidth * (estimatedCenterY - j) >= 0 && estimatedCenterX + binWidth * (estimatedCenterY - j) < length){
//							if(pixels[estimatedCenterX + binWidth * (estimatedCenterY - j)] != white)
//								heightTop = j;
//							else 
//								heightTop++;
//						}
//						else
//							break;
//					}	
//
//					// spätere randpunkte
//					int minX=estimatedCenterX, minY=estimatedCenterY, maxX=estimatedCenterX, maxY=estimatedCenterY;
//					int minXtemp=estimatedCenterX, minYtemp=estimatedCenterY, maxXtemp=estimatedCenterX, maxYtemp=estimatedCenterY;
//					
//					// laufvariablen
//					int xl=estimatedCenterX, xr=estimatedCenterX, yu=estimatedCenterY, yo=estimatedCenterY;
//					
//					while(pixels[yo*binWidth+x]==white && pixels[y*binWidth+xr]>0 && yo*binWidth+x != 0){
//						yo=yo-1;
//						minY=yo;
//					}
//					
//					//unten
//					
//					for(int g = 0; g < corrHeight / 2; g++){
//						
//					
//					//Abfrage, ob Arraygrenzen nicht überschritten werden
//						if(estimatedCenterX + binWidth * (estimatedCenterY + g) >= 0 && estimatedCenterX + binWidth * (estimatedCenterY + g) < length){
//						
//							if(pixels[estimatedCenterX + binWidth * (estimatedCenterY + g)] != white)
//								heightBottom = g;
//							else
//								heightBottom++;
//						}
//						else
//							break;
//					}
//					
//					//links
//					
//					for(int h = 0; h < corrWidth / 2; h++){
//						
//					//Abfrage, ob Arraygrenzen nicht überschritten werden
//						if(estimatedCenterX - h + binWidth * estimatedCenterY >= 0 && estimatedCenterX - h + binWidth * estimatedCenterY < length){	
//						
//							if(pixels[estimatedCenterX - h + binWidth * estimatedCenterY] != white)
//								widthLeft = h;
//							else 
//								widthLeft++;
//						}
//						else
//							break;
//					}
//					
//					//rechts
//					 
//					for(int k = 0; k < corrWidth / 2; k++){
//						
//					//Abfrage, ob Arraygrenzen nicht überschritten werden
//						if(estimatedCenterX + k + binWidth * estimatedCenterY >= 0 && estimatedCenterX + k + binWidth * estimatedCenterY < length){		
//						
//							if(pixels[estimatedCenterX + k + binWidth * estimatedCenterY] != white)
//								widthRight = k;
//							else 
//								widthRight++;
//						}
//						else
//							break;
//					}
//					
//					
//					int tmpWidth = Math.abs(widthLeft) + Math.abs(widthRight);
//					int tmpHeight = Math.abs(heightTop) + Math.abs(heightBottom);
//					
//					Cloud toAdd = new Cloud(estimatedCenterX, estimatedCenterY, tmpWidth, tmpHeight,numOfIteration);
//					currentCorrespondence.add(toAdd);
//				}
//				
//			}
//			
//			
//			//Andernfalls liegt das Zentrum nicht mehr im Bild
//			else
//				continue;
//			
//		}
//		
//		
//		return currentCorrespondence;
//	}
	
	//------------------------------------------------------------------------------------------------
	
	public static ArrayList<Cloud> Tracking3 (ArrayList<CloudPair> ref, ImageProcessor binary, int numOfIteration){
		System.out.println("Traking: " + numOfIteration);
		
		ArrayList<Cloud> cloudList = new ArrayList<Cloud>();
					
		
			
			int white = -1;//255
			int widthP = binary.getWidth();
			int heightP = binary.getHeight();
			byte counter=10;
		
			byte [] pixels = (byte[]) binary.getPixels();
			byte [] show = new byte[widthP*heightP];
			
			int length = pixels.length;
					
			
			// durchlaufe alle wolken
			while (ref.size()!=0){
			
			CloudPair cp= ref.remove(ref.size()-1); //poll
			Cloud c=cp.getCorrespondence();
					
			int height=c.getHeight();
			int width=c.getWidth();
			int x=c.getX();
			int y=c.getY();
			Vec2 motion=cp.getMotionVec();
			int dirX = motion.getX();
			int dirY = motion.getY();
			int estimatedCenterX;
			int estimatedCenterY;
			
			//noch zu tun:nähe zum rand prüfen?
			
			
if(x + dirX + y + dirY * widthP >= 0 && x + dirX + y + dirY * widthP < length){
				
			estimatedCenterX = x + dirX;
			estimatedCenterY = y + dirY;
			
if(pixels[estimatedCenterX + widthP * estimatedCenterY] != white){
	continue; //raus aus dem durchlauf
}	
}


			
			int incrY=height/10;
			int[]possibleY= new int[10];
			for(int i=-5; i<5; i++){
				if(y+i*incrY>0 && y+i*incrY <heightP){
				possibleY[i+5]=y+i*incrY;
				}
			}
			
			int incrX=height/10;
			int[]possibleX= new int[10];
			for(int i=-5; i<5; i++){
				if(x+i*incrX>0 && x+i*incrX <widthP)
				possibleX[i+5]=x+i*incrX;
			}
			
			
			// spätere randpunkte
			int minX=x, minY=y, maxX=x, maxY=y;
			int minXtemp=x, minYtemp=y, maxXtemp=x, maxYtemp=y;
			
			// laufvariablen
			int xl=x, xr=x, yu=y, yo=y;
			
			//x
			for(int i=0; i<10; i++){
			
			y=possibleY[i];
				
			// teste wie lange vom mittelpunkt der alten wolke in jede richtung gegangen werden kann
			while(pixels[y*widthP+xl]==white && pixels[y*widthP+xl]>0 && y*widthP+xl%widthP != 0){
				xl=xl-1;
				minXtemp=xl;
				show[y*widthP+xl]=counter;
			}
			
			while(pixels[y*widthP+xr]==white && pixels[y*widthP+xr]<widthP-1 && y*widthP+xr != (widthP-1)){
				xr=xr+1;
				maxXtemp=xr;
				show[y*widthP+xr]=counter;
			}
			
			if (minXtemp<minX)
				minX=minXtemp;
			
			if (maxXtemp<maxX)
				maxX=maxXtemp;
			
			}
			
			
			//y
			for(int i=0; i<10; i++){
			
				x=possibleX[i];
				
			
			
			while(pixels[yo*widthP+x]==white && pixels[y*widthP+xr]>0 && yo*widthP+x != 0){
				yo=yo-1;
				minY=yo;
				show[yo*widthP+x]=counter;
			}
			
			while(pixels[yu*widthP+x]==white && pixels[y*widthP+xr]<heightP-1 && yu*widthP+x != (widthP-1)){
				yu=yu+1;
				maxY=yu;
				show[yu*widthP+x]=counter;
			}
			
			if (minYtemp<minY)
				minY=minYtemp;
			
			if (maxYtemp<maxY)
				maxY=maxYtemp;
			
			}
			
			//neue wolke
			x=(minX+maxX)/2;
			y=(minY+maxY)/2;
			width=maxX-minX;
			height=maxY-minY;
			
			Cloud cn=new Cloud(x,y,width,height,numOfIteration);
			
			cloudList.add(cn);
			
			} // ende while
			
			
			
//			ImageProcessor ip= new ByteProcessor(widthP,heightP, show);
//			ImagePlus imp =new ImagePlus("show",ip);
//			imp.show();
			
			return cloudList;
			
		} // ende tracking
	
}
